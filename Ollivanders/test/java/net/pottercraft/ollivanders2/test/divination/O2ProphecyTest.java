package net.pottercraft.ollivanders2.test.divination;

import net.pottercraft.ollivanders2.Ollivanders2;
import net.pottercraft.ollivanders2.Ollivanders2API;
import net.pottercraft.ollivanders2.divination.O2Prophecies;
import net.pottercraft.ollivanders2.divination.O2Prophecy;
import net.pottercraft.ollivanders2.effect.O2EffectType;
import net.pottercraft.ollivanders2.test.testcommon.TestCommon;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.mockbukkit.mockbukkit.MockBukkit;
import org.mockbukkit.mockbukkit.ServerMock;
import org.mockbukkit.mockbukkit.entity.PlayerMock;

import java.io.File;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Comprehensive test suite for the {@link O2Prophecy} prophecy data object.
 * <p>
 * This test class validates the complete lifecycle and behavior of individual prophecy objects including
 * creation, aging, killing, fulfillment with varying accuracy levels, message broadcasting to players,
 * O2Effect application to targets, and special handling for offline players. O2Prophecy represents a
 * single prophecy generated by a divination spell that may be about a target player (prophecy of their future).
 * </p>
 * <p>
 * Test coverage includes:
 * <ul>
 * <li>Prophecy aging: time decreases with each {@link O2Prophecy#age()} call</li>
 * <li>Prophecy killing: state tracking via {@link O2Prophecy#isKilled()} and {@link O2Prophecy#kill()}</li>
 * <li>High accuracy fulfillment: successful prophecy application with effect and messages</li>
 * <li>Low accuracy fulfillment: failed prophecy with failure messages to prophet only</li>
 * <li>Message broadcasting: correct delivery to both target and prophet players</li>
 * <li>Effect application: O2Effect correctly applied to target with proper duration</li>
 * <li>Offline target handling: fulfillment deferred until target reconnects</li>
 * <li>Offline prophet handling: target still receives effects even if prophet is offline</li>
 * <li>Killed prophecy behavior: no effects or messages sent if killed before fulfillment</li>
 * </ul>
 * </p>
 * <p>
 * <strong>Design Note (Mega Test):</strong> This test is intentionally written as a single comprehensive test method
 * ({@link #prophecyTest()}) rather than multiple smaller tests. This pattern is used to avoid non-deterministic
 * test execution order issues with JUnit 5 when testing stateful systems.
 * </p>
 *
 * @see O2Prophecy the individual prophecy data object being tested
 * @see O2Prophecies the prophecy management system that uses O2Prophecy objects
 */
public class O2ProphecyTest {
    /**
     * The MockBukkit server instance for this test class.
     * <p>
     * Initialized once per test class in {@link #globalSetUp()} and used for player creation,
     * scheduler advancement (to simulate time passing), and server lifecycle management.
     * </p>
     */
    static ServerMock mockServer;

    /**
     * Maximum accuracy level for prophecies in this test.
     * <p>
     * Initialized from {@link O2Prophecy#maxAccuracy} in {@link #globalSetUp()}.
     * Used when creating test prophecy objects to represent 100% accuracy predictions (though 99 is used in tests).
     * </p>
     */
    static int maxAccuracy;

    /**
     * The Ollivanders2 plugin instance loaded for testing.
     * <p>
     * Initialized once per test class in {@link #globalSetUp()} using the default test configuration.
     * Required for creating O2Prophecy objects and accessing the Ollivanders2 API.
     * </p>
     */
    static Ollivanders2 testPlugin;

    /**
     * Mock player representing the prophet (divination caster).
     * <p>
     * Created in {@link #globalSetUp()} with name "prophet". Prophecies are created by this player and
     * they receive prophecy fulfillment/failure messages. Used for testing message broadcasting and offline state.
     * </p>
     */
    static PlayerMock prophet;

    /**
     * Mock player representing the target (prophecy subject).
     * <p>
     * Created in {@link #globalSetUp()} with name "target". Prophecies are about this player, and they receive
     * prophecy fulfillment messages and O2Effects when prophecies come true. Used for testing effect application,
     * message delivery, and offline/reconnect behavior.
     * </p>
     */
    static PlayerMock target;

    /**
     * Global test setup executed once before all tests in this class.
     * <p>
     * This setup performs:
     * <ul>
     * <li>MockBukkit server initialization via {@link MockBukkit#mock()}</li>
     * <li>Capturing the max accuracy value from {@link O2Prophecy#maxAccuracy}</li>
     * <li>Loading Ollivanders2 plugin with default test configuration</li>
     * <li>Creating two mock players: "prophet" (the diviner/caster) and "target" (prophecy subject)</li>
     * <li>Advancing the server scheduler by {@link TestCommon#startupTicks} (typically 20 ticks) to allow the plugin
     * scheduler to initialize completely (the scheduler has a built-in startup delay)</li>
     * </ul>
     * </p>
     * <p>
     * This method runs once per test class (via {@code @BeforeAll}) since server and plugin initialization
     * is expensive. The two test players (prophet and target) are reused throughout the test scenarios.
     * </p>
     */
    @BeforeAll
    static void globalSetUp() {
        mockServer = MockBukkit.mock();
        maxAccuracy = O2Prophecy.maxAccuracy;

        testPlugin = MockBukkit.loadWithConfig(Ollivanders2.class, new File("Ollivanders/test/resources/default_config.yml"));
        prophet = mockServer.addPlayer("prophet");
        target = mockServer.addPlayer("target");

        // advance the server to let the scheduler start
        mockServer.getScheduler().performTicks(TestCommon.startupTicks);
    }

    /**
     * Comprehensive integration test of O2Prophecy functionality.
     * <p>
     * This mega test method validates the complete prophecy object lifecycle through a sequential
     * series of test scenarios executed in controlled order. The test is designed as a single method
     * to avoid JUnit 5's non-deterministic test execution order when testing stateful systems.
     * </p>
     * <p>
     * Test scenarios (executed sequentially):
     * </p>
     * <ol>
     * <li><strong>Prophecy Aging:</strong>
     *   Tests {@link O2Prophecy#age()} method. Creates a prophecy with time value, calls age(),
     *   and verifies the time decreases by exactly 1 tick
     * </li>
     * <li><strong>Prophecy Killing:</strong>
     *   Tests {@link O2Prophecy#kill()} and {@link O2Prophecy#isKilled()} methods.
     *   Verifies prophecy starts not killed, then transitions to killed state
     * </li>
     * <li><strong>High Accuracy Fulfillment:</strong>
     *   Tests {@link O2Prophecy#fulfill()} with high accuracy (99). Verifies:
     *   <ul>
     *   <li>Both target and prophet receive prophecy messages</li>
     *   <li>Target message contains prophet's name and the prophecy message</li>
     *   <li>Messages contain "And so came to pass the prophecy" success phrase</li>
     *   <li>Target receives the O2Effect (not the prophet)</li>
     *   <li>Effect expires after the specified duration</li>
     *   </ul>
     * </li>
     * <li><strong>Low Accuracy Fulfillment:</strong>
     *   Tests {@link O2Prophecy#fulfill()} with low accuracy (0). Verifies:
     *   <ul>
     *   <li>Only prophet receives a message (failure notification)</li>
     *   <li>Target receives no message</li>
     *   <li>Prophecy message contains "did not come to pass"</li>
     *   <li>No O2Effect is applied to target</li>
     *   </ul>
     * </li>
     * <li><strong>Offline Target Handling:</strong>
     *   Tests prophecy fulfillment when target is offline. Verifies:
     *   <ul>
     *   <li>Target disconnects before prophecy fulfill() is called</li>
     *   <li>Prophet does not receive messages while target is offline</li>
     *   <li>Fulfillment is deferred until target reconnects</li>
     *   </ul>
     * </li>
     * <li><strong>Offline Target Reconnection:</strong>
     *   Tests that deferred fulfillment completes when target reconnects. Verifies:
     *   <ul>
     *   <li>Both target and prophet receive messages after reconnection</li>
     *   <li>Target receives the O2Effect</li>
     *   </ul>
     * </li>
     * <li><strong>Offline Prophet Handling:</strong>
     *   Tests prophecy fulfillment when prophet is offline. Verifies:
     *   <ul>
     *   <li>Target still receives prophecy message even if prophet is offline</li>
     *   <li>Target still receives the O2Effect</li>
     *   </ul>
     * </li>
     * <li><strong>Killed Prophecy Blocking Fulfillment:</strong>
     *   Tests that killed prophecies do not fulfill. Verifies:
     *   <ul>
     *   <li>Prophecy is killed via {@link O2Prophecy#kill()}</li>
     *   <li>{@link O2Prophecy#fulfill()} is called on a killed prophecy</li>
     *   <li>No messages are sent to target or prophet</li>
     *   <li>No O2Effect is applied to target</li>
     *   </ul>
     * </li>
     * </ol>
     */
    @Test
    void prophecyTest() {
        Ollivanders2.debug = true;
        String prophecyMessage = "test prophecy message";
        O2EffectType prophecyEffect = O2EffectType.FAST_LEARNING;
        int effectDuration = prophecyEffect.getMinDuration();

        // test age()
        O2Prophecy prophecy = new O2Prophecy(testPlugin, prophecyEffect, prophecyMessage, target.getUniqueId(), prophet.getUniqueId(), 10, effectDuration, 99);

        long age = prophecy.getTime();
        prophecy.age();
        assertEquals((age - 1), prophecy.getTime(), "prophecy.age() did not reduce prophecy age by 1");

        // test kill() and isKilled()
        assertFalse(prophecy.isKilled(), "Prophecy set to killed when not expected");
        prophecy.kill();
        assertTrue(prophecy.isKilled(), "Prophecy not set to killed when expected");

        // test fulfill
        // a prophecy with max accuracy - so should succeed
        Ollivanders2.maxSpellLevel = true;
        prophecy = new O2Prophecy(testPlugin, prophecyEffect, prophecyMessage, target.getUniqueId(), prophet.getUniqueId(), 10, effectDuration, 99);
        prophecy.fulfill();
        mockServer.getScheduler().performTicks(5);

        // prophecy sent a message to both the target and player
        String targetReceivedMessage = target.nextMessage();
        assertNotNull(targetReceivedMessage, "target did not receive a prophecy message");
        String prophetReceivedMessage = prophet.nextMessage();
        assertNotNull(prophetReceivedMessage, "prophet did not receive a prophecy message");

        // target got the prophecy broadcast with the prophet's name and the prophecy message
        assertTrue(targetReceivedMessage.contains(prophet.getName()), "prophecy broadcast did not contain prophet's name");
        assertTrue(targetReceivedMessage.contains("And so came to pass the prophecy"), "Prophecy broadcast message does not contain 'And so came to pass the prophecy'");
        assertTrue(targetReceivedMessage.contains(prophecyMessage), "prophecy broadcast did not contain expected prophecy message, expected: " + prophecyMessage + ", actual: " + targetReceivedMessage);

        // prophet also got the prophecy broadcast
        assertTrue(prophetReceivedMessage.contains("And so came to pass the prophecy"), "Prophet did not receive the prophecy success broadcast message");

        // prophecy added the effect to the target
        assertTrue(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target does not have prophecy effect");

        // prophecy does not add the effect to the prophet
        assertFalse(Ollivanders2API.getPlayers().playerEffects.hasEffect(prophet.getUniqueId(), prophecyEffect), "Prophet has the prophecy effect");

        // effect duration is correct
        mockServer.getScheduler().performTicks(effectDuration); // we've already done 5 ticks, doing effectDuration more should ensure the effect has been removed
        assertFalse(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target still has the prophecy effect after expected duration");

        // low accuracy prophecy sends failure message to prophet and nothing to target, no effect added to target
        Ollivanders2.maxSpellLevel = false;
        prophecyMessage = "low accuracy prophecy";
        prophecy = new O2Prophecy(testPlugin, prophecyEffect, prophecyMessage, target.getUniqueId(), prophet.getUniqueId(), 10, 10, 0);
        prophecy.fulfill();
        prophetReceivedMessage = prophet.nextMessage();
        assertNotNull(prophetReceivedMessage, "prophet did not receive a prophecy message");
        assertTrue(prophetReceivedMessage.contains("did not come to pass"), "Prophet did not receive the prophecy failure message");
        targetReceivedMessage = target.nextMessage();
        assertNull(targetReceivedMessage, "Target received prophecy message when prophecy failed");
        assertFalse(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target has the prophecy effect when prophecy failed");

        // prophecy fulfillment deferred when target is offline
        prophecy = new O2Prophecy(testPlugin, prophecyEffect, "test", target.getUniqueId(), prophet.getUniqueId(), 3, effectDuration, 99);
        Ollivanders2API.getProphecies().addProphecy(prophecy); // add it to the prophecy manager so we can test the persistence
        target.disconnect();
        mockServer.getScheduler().performTicks(5); // advance the ticks past the delay time so O2Prophecies will call fulfill
        prophetReceivedMessage = prophet.nextMessage();
        assertNull(prophetReceivedMessage, "Prophet received prophecy message when target offline: " + prophetReceivedMessage);

        // prophecy is fulfilled when target comes back online - technically this is testing O2Prophecies.java but it is easier to do here when we have the server in the right state.
        target.reconnect();
        mockServer.getScheduler().performTicks(5);
        assertNotNull(prophet.nextMessage(), "Prophet did not receive prophecy message when target reconnected");
        assertNotNull(target.nextMessage(), "Target did not receive prophecy message when they reconnected");
        assertTrue(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target does not have prophecy effect");

        // prophecies are fulfilled when prophets are offline
        mockServer.getScheduler().performTicks(effectDuration); // expire the current effect
        prophecy = new O2Prophecy(testPlugin, prophecyEffect, prophecyMessage, target.getUniqueId(), prophet.getUniqueId(), 10, 10, 99);
        prophet.disconnect();
        mockServer.getScheduler().performTicks(5);
        prophecy.fulfill();
        assertNotNull(target.nextMessage(), "Target did not receive prophecy message when they reconnected");
        assertTrue(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target does not have prophecy effect");

        // prophecies are not fulfilled if prophecy already killed
        prophecyEffect = O2EffectType.BABBLING;
        prophecy = new O2Prophecy(testPlugin, prophecyEffect, prophecyMessage, target.getUniqueId(), prophet.getUniqueId(), 10, 10, 99);
        prophecy.kill();
        prophecy.fulfill();
        assertNull(target.nextMessage(), "target received prophecy message when prophecy was killed before fulfill()");
        assertNull(prophet.nextMessage(), "prophet received prophecy message when prophecy was killed before fulfill()");
        assertFalse(Ollivanders2API.getPlayers().playerEffects.hasEffect(target.getUniqueId(), prophecyEffect), "Target has the prophecy effect when prophecy was killed before fulfill()");
    }

    /**
     * Global test teardown executed once after all tests in this class have completed.
     * <p>
     * This teardown performs:
     * <ul>
     * <li>Unmocking the MockBukkit server via {@link MockBukkit#unmock()}, releasing all server resources
     * and unloading all loaded plugins</li>
     * <li>Disabling debug mode on the Ollivanders2 plugin (was enabled at start of test)</li>
     * </ul>
     * This cleanup prevents resource leaks and interference between test classes when running
     * the complete test suite.
     * </p>
     */
    @AfterAll
    static void globalTearDown () {
        MockBukkit.unmock();
        Ollivanders2.debug = false;
    }
}
