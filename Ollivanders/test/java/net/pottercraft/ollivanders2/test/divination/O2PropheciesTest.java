package net.pottercraft.ollivanders2.test.divination;

import net.pottercraft.ollivanders2.Ollivanders2;
import net.pottercraft.ollivanders2.Ollivanders2API;
import net.pottercraft.ollivanders2.divination.O2Prophecies;
import net.pottercraft.ollivanders2.divination.O2Prophecy;
import net.pottercraft.ollivanders2.effect.O2EffectType;
import net.pottercraft.ollivanders2.test.testcommon.TestCommon;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.mockbukkit.mockbukkit.MockBukkit;
import org.mockbukkit.mockbukkit.ServerMock;
import org.mockbukkit.mockbukkit.entity.PlayerMock;

import java.io.File;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Comprehensive test suite for the {@link O2Prophecies} prophecy management system.
 * <p>
 * This test class validates the complete prophecy lifecycle including creation, retrieval, aging,
 * persistence to disk, and handling of player offline/online transitions. O2Prophecies manages
 * the storage and retrieval of prophecies generated by divination spells, maintaining separate
 * lists for active prophecies (players online) and offline prophecies (players disconnected).
 * </p>
 * <p>
 * Test coverage includes:
 * <ul>
 * <li>Adding prophecies to the system via {@link O2Prophecies#addProphecy(O2Prophecy)}</li>
 * <li>Retrieving prophecies by target player ({@link O2Prophecies#getProphecyAboutPlayer(java.util.UUID)})</li>
 * <li>Retrieving prophecies by creator/prophet ({@link O2Prophecies#getProphecyByPlayer(java.util.UUID)})</li>
 * <li>Prophecy aging and automatic expiration based on delay ticks</li>
 * <li>Saving prophecies to disk ({@link O2Prophecies#saveProphecies()})</li>
 * <li>Loading prophecies from disk ({@link O2Prophecies#loadProphecies()})</li>
 * <li>Player disconnect/reconnect handling with offline prophecy migration</li>
 * <li>Retrieving prophecies for both online and offline players ({@link O2Prophecies#getProphecy(java.util.UUID)})</li>
 * </ul>
 * </p>
 * <p>
 * <strong>Design Note (Mega Test):</strong> This test is intentionally written as a single comprehensive test method
 * ({@link #propheciesTest()}) rather than multiple smaller tests. This pattern is used to avoid non-deterministic
 * test execution order issues with JUnit 5 when testing stateful systems. All test scenarios are executed sequentially
 * in a controlled order within a single test method, ensuring dependent operations execute in the correct sequence.
 * </p>
 *
 * @see O2Prophecies the prophecy management system being tested
 * @see O2Prophecy individual prophecy data objects
 */
public class O2PropheciesTest {
    /**
     * The MockBukkit server instance for this test class.
     * <p>
     * Initialized once per test class in {@link #globalSetUp()} and used for player creation,
     * scheduler advancement (to simulate time passing), and server lifecycle management.
     * </p>
     */
    static ServerMock mockServer;

    /**
     * The Ollivanders2 plugin instance loaded for testing.
     * <p>
     * Initialized once per test class in {@link #globalSetUp()} using the default test configuration.
     * Provides access to plugin APIs and is used when creating prophecy objects.
     * </p>
     */
    static Ollivanders2 testPlugin;

    /**
     * The O2Prophecies system being tested.
     * <p>
     * Initialized in {@link #globalSetUp()} by retrieving the singleton instance from
     * {@link Ollivanders2API#getProphecies()}. Manages active and offline prophecy lists,
     * disk persistence, and player join/leave event handling.
     * </p>
     */
    static O2Prophecies prophecies;

    /**
     * Number of ticks before a prophecy expires due to age.
     * <p>
     * Set to 10 ticks for testing purposes. In tests, the scheduler is advanced by this amount
     * to simulate time passing and trigger prophecy expiration.
     * </p>
     */
    static int delayTicks = 10;

    /**
     * Number of ticks the prophecy effect lasts after the prophecy is retrieved.
     * <p>
     * Set to 10 ticks for testing purposes. This represents the duration of the O2Effect
     * that is applied to the target player when a prophecy is revealed to them.
     * </p>
     */
    static int effectDurationTicks = 10;

    /**
     * Maximum accuracy level for prophecies in this test.
     * <p>
     * Initialized from {@link O2Prophecy#maxAccuracy} in {@link #globalSetUp()}.
     * Used when creating test prophecy objects to represent 100% accuracy predictions.
     * </p>
     */
    static int maxAccuracy;

    /**
     * Global test setup executed once before all tests in this class.
     * <p>
     * This setup performs:
     * <ul>
     * <li>MockBukkit server initialization via {@link MockBukkit#mock()}</li>
     * <li>Capturing the max accuracy value from {@link O2Prophecy#maxAccuracy}</li>
     * <li>Loading Ollivanders2 plugin with default test configuration</li>
     * <li>Retrieving the O2Prophecies singleton instance from {@link Ollivanders2API#getProphecies()}</li>
     * <li>Advancing the server scheduler by {@link TestCommon#startupTicks} (typically 20 ticks) to allow the plugin
     * scheduler to initialize completely (the scheduler has a built-in startup delay)</li>
     * </ul>
     * </p>
     * <p>
     * This method runs once per test class (via {@code @BeforeAll}) since server and plugin initialization
     * is expensive and the prophecy system is stateless between the single test method execution.
     * </p>
     */
    @BeforeAll
    static void globalSetUp() {
        mockServer = MockBukkit.mock();
        maxAccuracy = O2Prophecy.maxAccuracy;

        testPlugin = MockBukkit.loadWithConfig(Ollivanders2.class, new File("Ollivanders/test/resources/default_config.yml"));
        prophecies = Ollivanders2API.getProphecies();

        // advance the server to let the scheduler start
        mockServer.getScheduler().performTicks(TestCommon.startupTicks);
    }

    /**
     * Comprehensive integration test of O2Prophecies functionality.
     * <p>
     * This mega test method validates the complete prophecy management system through a sequential
     * series of test scenarios executed in controlled order. The test is designed as a single method
     * to avoid JUnit 5's non-deterministic test execution order when testing stateful systems.
     * </p>
     * <p>
     * Test scenarios (executed sequentially):
     * </p>
     * <ol>
     * <li><strong>Prophecy Creation and Retrieval:</strong>
     *   Creates 1 prophecy, verifies it's added to the system, and can be retrieved by:
     *   <ul>
     *   <li>Target player UUID ({@link O2Prophecies#getProphecyAboutPlayer(java.util.UUID)})</li>
     *   <li>Prophet/creator UUID ({@link O2Prophecies#getProphecyByPlayer(java.util.UUID)})</li>
     *   <li>Prophecy content search</li>
     *   </ul>
     * </li>
     * <li><strong>Negative Retrieval Tests:</strong>
     *   Verifies that querying for non-existent prophecies returns null
     * </li>
     * <li><strong>Prophecy Aging and Expiration:</strong>
     *   Advances the server scheduler to trigger age-based prophecy expiration.
     *   Verifies prophecies are removed after {@code delayTicks} elapse
     * </li>
     * <li><strong>Disk Persistence:</strong>
     *   Creates 2 prophecies, saves them to disk via {@link O2Prophecies#saveProphecies()},
     *   clears the in-memory list, then loads them back via {@link O2Prophecies#loadProphecies()}.
     *   Verifies loaded prophecies have correct content and can be retrieved
     * </li>
     * <li><strong>Player Disconnect/Reconnect Handling:</strong>
     *   Tests the offline prophecy system:
     *   <ul>
     *   <li>Disconnects a player, ages prophecies to trigger offline migration</li>
     *   <li>Verifies prophecies moved from active to offline list</li>
     *   <li>Reconnects the player, verifies offline prophecies move back to active list</li>
     *   </ul>
     * </li>
     * <li><strong>Universal getProphecy() Method:</strong>
     *   Tests {@link O2Prophecies#getProphecy(java.util.UUID)} which works for both:
     *   <ul>
     *   <li>Online players (retrieves from active list)</li>
     *   <li>Offline players (retrieves from offline list)</li>
     *   <li>Players that transition to offline after aging</li>
     *   </ul>
     * </li>
     * </ol>
     */
    @Test
    void propheciesTest() {
        Ollivanders2.debug = true;
        PlayerMock prophet1 = mockServer.addPlayer("Prophet1");
        PlayerMock prophet2 = mockServer.addPlayer("Prophet2");
        PlayerMock target1 = mockServer.addPlayer("Target1");
        PlayerMock target2 = mockServer.addPlayer("Target2");

        // make sure we're starting with a clean list
        assertEquals(0, prophecies.getProphecies().size(), "Tests did not start out with empty prophecies list.");

        // add a prophecy
        String message1 = "test prophecy";
        prophecies.addProphecy(new O2Prophecy(testPlugin, O2EffectType.UNLUCK, message1, target1.getUniqueId(), prophet1.getUniqueId(), delayTicks, effectDurationTicks, maxAccuracy));

        // number of prophecies increases by 1
        assertEquals(1, prophecies.getProphecies().size(), "The number of prophecies did not increase by 1 after prophecies.addProphecy()");

        // we can find a prophecy with the expected message
        assertTrue(TestCommon.containsStringMatch(prophecies.getProphecies(), message1), "Did not find prophecy with matching message, " + message1);

        // we can find the prophecy about target1
        O2Prophecy prophecy = prophecies.getProphecyAboutPlayer(target1.getUniqueId());
        assertNotNull(prophecy, "Prophecy was null after prophecies.addProphecy()");
        assertTrue(prophecy.getProphecyMessage().contains(message1), "Prophecy did not have expected message");

        // we do find a prophecy about target2
        prophecy = prophecies.getProphecyAboutPlayer(target2.getUniqueId());
        assertNull(prophecy, "prophecies.getProphecyAboutPlayer(target2.getUniqueId()) was not null");

        // we do not find a prophet about prophet1
        prophecy = prophecies.getProphecyAboutPlayer(prophet1.getUniqueId());
        assertNull(prophecy, "prophecies.getProphecyAboutPlayer(prophet1.getUniqueId()) was not null");

        // we can find a prophecy by prophet1
        prophecy = prophecies.getProphecyByPlayer(prophet1.getUniqueId());
        assertNotNull(prophecy, "prophecies.getProphecyByPlayer(prophet1.getUniqueId()) was null");
        assertTrue(prophecy.getProphecyMessage().contains(message1), "Prophecy did not have expected message");

        // we do not find a prophecy by prophet2
        prophecy = prophecies.getProphecyByPlayer(prophet2.getUniqueId());
        assertNull(prophecy, "prophecies.getProphecyByPlayer(prophet2.getUniqueId()) is not null");

        // we do not find a prophecy by target1
        prophecy = prophecies.getProphecyByPlayer(target1.getUniqueId());
        assertNull(prophecy, "prophecies.getProphecyByPlayer(target1.getUniqueId()) was not null");

        // test upkeep processing
        // advance the server by 1 tick and make sure the number of prophecies has not changed
        mockServer.getScheduler().performTicks(1);
        assertEquals(1, prophecies.getProphecies().size(), "After " + TestCommon.startupTicks + " game ticks, number of prophecies changed.");

        // advance the server by delayTicks so the prophecy ages out
        mockServer.getScheduler().performTicks(delayTicks);
        assertEquals(0, prophecies.getProphecies().size(), "After " + delayTicks + " more game ticks, prophecies did not expire due to age");

        // test saving and loading prophecies
        // add 2 new prophecies
        message1 = "test prophecy 1";
        prophecies.addProphecy(new O2Prophecy(testPlugin, O2EffectType.UNLUCK, message1, target1.getUniqueId(), prophet1.getUniqueId(), delayTicks, effectDurationTicks, maxAccuracy));
        String message2 = "test prophecy 2";
        prophecies.addProphecy(new O2Prophecy(testPlugin, O2EffectType.UNLUCK, message2, target2.getUniqueId(), prophet2.getUniqueId(), delayTicks, effectDurationTicks, maxAccuracy));
        // save them
        prophecies.saveProphecies();
        assertEquals(2, prophecies.getProphecies().size(), "prophecies.getProphecies().size() not 2 after adding 2 prophecies");
        // clear the loaded prophecies
        prophecies.resetProphecies();
        assertEquals(0, prophecies.getProphecies().size(), "prophecies.getProphecies().size() not 0 after prophecies.resetProphecies();");
        // load saved prophecies
        prophecies.loadProphecies();
        assertEquals(2, prophecies.getProphecies().size(), "prophecies.getProphecies().size() not 2 after prophecies.loadProphecies();");
        // now make sure the loaded prophecies are right
        prophecy = prophecies.getProphecyByPlayer(prophet1.getUniqueId());
        assertNotNull(prophecy, "prophecies.getProphecyByPlayer(prophet1.getUniqueId()) was null after prophecies.loadProphecies()");
        assertTrue(prophecy.getProphecyMessage().contains(message1), "prophecy did not have expected message");
        prophecy = prophecies.getProphecyByPlayer(prophet2.getUniqueId());
        assertNotNull(prophecy, "prophecies.getProphecyByPlayer(prophet2.getUniqueId()) was null after prophecies.loadProphecies()");
        assertTrue(prophecy.getProphecyMessage().contains(message2), "prophecy did not have expected message");

        // test onJoin
        // disconnect target1
        target1.disconnect();
        // age the prophecies so that theirs moves to offlineProphecies
        mockServer.getScheduler().performTicks(delayTicks + 1);
        // verify the prophecies have moved to offline (should have 0 in active list)
        assertEquals(0, prophecies.activeProphecyCount(), "Prophecies did not move to offline after " + (delayTicks + 1) + " ticks.");
        // reconnect target1
        target1.reconnect();
        // verify onJoin() moved their offlineProphecy back to the active list
        assertEquals(1, prophecies.activeProphecyCount(), "onJoin did not add an active prophecy for target1 on reconnect");

        // getProphecy will return a prophecy about the specified player when they are online
        prophecies.resetProphecies(); // clear the prophecies to reset
        prophecies.addProphecy(new O2Prophecy(testPlugin, O2EffectType.UNLUCK, message2, target2.getUniqueId(), prophet2.getUniqueId(), delayTicks, effectDurationTicks, maxAccuracy));
        assertNotNull(prophecies.getProphecy(target2.getUniqueId()));

        // getProphecy will return a prophecy about the specified player when they are offline
        target2.disconnect();
        assertNotNull(prophecies.getProphecy(target2.getUniqueId()));

        // getProphecy will return a prophecy about the specified player when it has moved to the offline list
        mockServer.getScheduler().performTicks(delayTicks + 1);
        assertNotNull(prophecies.getProphecy(target2.getUniqueId()));
    }

    /**
     * Global test teardown executed once after all tests in this class have completed.
     * <p>
     * This teardown performs:
     * <ul>
     * <li>Clearing all prophecies from both active and offline lists via {@link O2Prophecies#resetProphecies()}</li>
     * <li>Unmocking the MockBukkit server via {@link MockBukkit#unmock()}, releasing all server resources
     * and unloading all loaded plugins</li>
     * <li>Disabling debug mode on the Ollivanders2 plugin (was enabled at start of test)</li>
     * </ul>
     * This cleanup prevents resource leaks and interference between test classes when running
     * the complete test suite.
     * </p>
     */
    @AfterAll
    static void globalTearDown () {
        prophecies.resetProphecies();
        MockBukkit.unmock();

        Ollivanders2.debug = false;
    }
}
